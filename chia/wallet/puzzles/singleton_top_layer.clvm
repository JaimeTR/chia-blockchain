(mod (MOD_HASH LAUNCHER_ID LAUNCHER_PUZZLE_HASH INNER_PUZZLE parent_info my_amount inner_solution)

; MOD_HASH, LAUNCHER_ID, LAUNCHER_PUZZLE_HASH, INNER_PUZZLE are curried in by the wallet

; EXAMPLE SOLUTION '(0xfadeddab 0xdeadbeef 1 (0xdeadbeef 200) 50 ((51 0xfadeddab 100) (60 "trash") (51 deadbeef 0)))'

  (include condition_codes.clvm)
  (include curry-and-treehash.clinc)

  ; takes a lisp tree and returns the hash of it
  (defun sha256tree1 (TREE)
      (if (l TREE)
          (sha256 2 (sha256tree1 (f TREE)) (sha256tree1 (r TREE)))
          (sha256 1 TREE)
      )
  )

  ;; return the full puzzlehash for a singleton with the innerpuzzle curried in
  (defun-inline calculate_outer_puzzle_hash (MOD_HASH LAUNCHER_ID LAUNCHER_PUZZLE_HASH inner_puzzle_hash)
     (puzzle-hash-of-curried-function MOD_HASH inner_puzzle_hash (sha256 1 LAUNCHER_PUZZLE_HASH) (sha256 1 LAUNCHER_ID) (sha256 1 MOD_HASH))
  )

  ; assembles information from the solution to create our own full ID including asserting our parent is a coloured coin
  (defun-inline create_my_ID (MOD_HASH LAUNCHER_ID LAUNCHER_PUZZLE_HASH inner_puzzle_hash parent_parent parent_inner_puzzle parent_amount my_amount)
    (sha256 (sha256 parent_parent (calculate_outer_puzzle_hash MOD_HASH LAUNCHER_ID LAUNCHER_PUZZLE_HASH parent_inner_puzzle) parent_amount)
            (calculate_outer_puzzle_hash MOD_HASH LAUNCHER_ID LAUNCHER_PUZZLE_HASH my_inner_puzzle_hash)
            my_amount)
  )

  ; This is the puzzlehash of the singleton_launcher which you can find in singleton_launcher.clvm
  ; We commit to this because we want to guarantee that we, and all other singletons like us, came from a puzzle which only creates one output
  (defconstant launcher_puzzle_hash 0xeff07522495060c066f66f32acc2a77e3a3e737aca8baea4d1a64ea4cdc13da9)

  ; if we are the child of genesis check that the genesis puzzle only creates me
  ; if we are the child of genesis check that our parent actually is the genesis coin

  (defun check_launcher (launcher_parent LAUNCHER_ID LAUNCHER_PUZZLE_HASH launcher_amount my_full_puzzle_hash my_amount)
    (if (= LAUNCHER_ID (sha256 launcher_parent LAUNCHER_PUZZLE_HASH launcher_amount))
      (list ASSERT_MY_COIN_ID (sha256 LAUNCHER_ID my_full_puzzle_hash my_amount))
      (x)
    )
  )

  ; if parent_info is a list of length 2 then we are the eve coin
  ; if the parent_info is a list of length 3 then we are a singleton somewhere down the lineage
  ; if we are eve, then check the genesis was a launcher puzzle
  ; if we are a child of lineage, do the standard singleton lineage check

  (defun check_my_amount_and_ID (MOD_HASH LAUNCHER_ID LAUNCHER_PUZZLE_HASH my_inner_puzzle_hash parent_info my_amount)
    (if (logand my_amount 1)
      (if (r (r parent_info))
        (list ASSERT_MY_COIN_ID
              (create_my_ID MOD_HASH
                            LAUNCHER_ID
                            LAUNCHER_PUZZLE_HASH
                            my_inner_puzzle_hash
                            (f parent_info)
                            (f (r parent_info))
                            (f (r (r parent_info)))
                            my_amount))
        (check_launcher (f parent_info)
                        LAUNCHER_ID
                        LAUNCHER_PUZZLE_HASH
                        (f (r parent_info))
                        (calculate_outer_puzzle_hash MOD_HASH LAUNCHER_ID LAUNCHER_PUZZLE_HASH my_inner_puzzle_hash)
                        my_amount)
      )
      (x)
    )
  )

  ; "assert" is a macro that wraps repeated instances of "if"
  ; usage: (assert A0 A1 ... An R)
  ; all of A0, A1, ... An must evaluate to non-null, or an exception is raised
  ; return the value of R (if we get that far)

  (defmacro assert items
    (if (r items)
        (list if (f items) (c assert (r items)) (q . (x)))
      (f items)
      )
    )

  ;; boolean and macro
  ;; This lets you write something like (if (and COND1 COND2 COND3) (do-something) (do-something-else))
  (defmacro and ARGS
    (if ARGS
        (qq (if (unquote (f ARGS))
                (unquote (c and (r ARGS)))
              ()
              ))
      1)
    )

    ;; take a boolean and a non-empty list of conditions
    ;; strip off the first condition if a boolean is set
    ;; this is used to remove `(CREATE_COIN xxx -113)`
    ;; pretty sneaky, eh?
    (defun strip_first_condition_if (boolean condition_list)
      (if boolean
        (r condition_list)
        condition_list
      )
    )

    (defun morph_condition (condition MOD_HASH LAUNCHER_ID LAUNCHER_PUZZLE_HASH)
      (list (f condition) (calculate_outer_puzzle_hash MOD_HASH LAUNCHER_ID LAUNCHER_PUZZLE_HASH (f (r condition))) (f (r (r condition))))
    )

    ;; return the value of the coin created if this is a `CREATE_COIN` condition, or 0 otherwise
    (defun created_coin_value_or_0 (condition)
      (if (= (f condition) CREATE_COIN)
          (f (r (r condition)))
          0
      )
    )

    ;;
    (defun odd_cons_m113 (output_amount)
      (c
        (= (logand output_amount 1) 1)
        (= output_amount -113)
      )
    )

    ; Assert exactly one output with odd value exists - ignore it if value is -113

    ;; this function iterates over the output conditions from the inner puzzle & solution
    ;; and both checks that exactly one unique singleton child is created (with odd valued output),
    ;; and wraps the inner puzzle with this same singleton wrapper puzzle
    ;;
    ;; The special case where the output value is -113 means a child singleton is intentionally
    ;; *NOT* being created, thus forever ending this singleton's existence

    (defun check_and_morph_conditions_for_singleton (MOD_HASH LAUNCHER_ID LAUNCHER_PUZZLE_HASH conditions odd_output_found)
      (if conditions
          (morph_next_condition MOD_HASH LAUNCHER_ID LAUNCHER_PUZZLE_HASH conditions odd_output_found (odd_cons_m113 (created_coin_value_or_0 (f conditions))))
            (if (odd_output_found)
                0
                (x)  ;; no odd output found
            )
          )
     )

     ;; a continuation of `check_and_morph_conditions_for_singleton` with booleans `output_odd` and `output_m113`
     ;; precalculated
     (defun morph_next_condition (MOD_HASH LAUNCHER_ID LAUNCHER_PUZZLE_HASH conditions odd_output_found (output_odd . output_m113))
         (assert
            (not (all output_odd odd_output_found))
            (strip_first_condition_if
               output_m113
               (c (if output_odd
                      (morph_condition (f conditions) MOD_HASH LAUNCHER_ID LAUNCHER_PUZZLE_HASH)
                      (f conditions)
                  )
                  (check_and_morph_conditions_for_singleton MOD_HASH LAUNCHER_ID LAUNCHER_PUZZLE_HASH (r conditions) (any output_odd odd_output_found))
               )
            )
        )
     )

  (defun check_id_and_check_outputs (MOD_HASH LAUNCHER_ID LAUNCHER_PUZZLE_HASH parent_info inner_puzzle_hash my_amount inner_puzzle inner_solution)
    (c (check_my_amount_and_ID MOD_HASH LAUNCHER_ID LAUNCHER_PUZZLE_HASH inner_puzzle_hash parent_info my_amount)
       (check_and_morph_conditions_for_singleton MOD_HASH LAUNCHER_ID LAUNCHER_PUZZLE_HASH (a inner_puzzle (c (list LAUNCHER_ID inner_puzzle_hash my_amount parent_info) inner_solution)) 0))
  )

  ;main
  (check_id_and_check_outputs MOD_HASH LAUNCHER_ID launcher_puzzle_hash parent_info (sha256tree1 INNER_PUZZLE) my_amount INNER_PUZZLE inner_solution)
)
